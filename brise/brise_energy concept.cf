
abstract Hyperparameter {
    Type -> predefined
    Region -> string
    [if isparent self == False then Region = TopLevel]
    [if parent.Type == Category then Region = path parent else Region = parent.Region]
}

abstract NominalHyperparameter: Hyperparameter {
    Categories -> predefined
    Default -> string
    [Type = NominalHyperparameter]
    [Default in Categories]
    [Categories = self.childs where Type == Category]
}

abstract Category {
    Type -> predefined
    Region -> string
    [Type = Category]
    [Region = parent.Region]
    [parent.type == NominalHyperparameter]
}

abstract OrdinalHyperparameter: Hyperparameter {
    Categories -> predefined
    Default -> string
    [Type = OrdinalHyperparameter]
    [Default in Categories]
}


abstract FloatHyperparameter: Hyperparameter {
    Lower -> predefined
    Upper -> predefined
    Default -> float
    [Default >= Lower]
    [Default <= Upper]
    [Type = FloatHyperparameter]
}

abstract FloatOrdinalHyperparameter: Hyperparameter {
    Categories -> predefined
    Default -> float
    [Type = FloatOrdinalHyperparameter]
    [Default in Categories]
}

abstract IntegerHyperparameter: Hyperparameter {
    Lower -> predefined
    Upper -> predefined
    Default -> integer
    [Default >= Lower]
    [Default <= Upper]
    [Type = IntegerHyperparameter]
}

abstract IntegerOrdinalHyperparameter: Hyperparameter {
    Categories -> predefined
    Default -> integer
    [Type = IntegerOrdinalHyperparameter]
    [Default in Categories]
}

Context {
    Experiment {
        TaskConfiguration {
            // TaskConfiguration Data here
        }

        Title -> string
        Regions -> predefined
        [Regions = unique Region in Context.Experiment.SearchSpace]
        SearchSpace: {
            Frequency: FloatOrdinalHyperparameter{
                [Categories = {1200.0, 1300.0, 1400.0, 1600.0, 1700.0, 1800.0, 1900.0, 2000.0, 2200.0, 2300.0, 2400.0, 2500.0, 2700.0, 2800.0, 2900.0, 2901.0}]
            }
            Threads: IntegerOrdinalHyperparameter{
                [Categories = {1, 2, 4, 8, 16, 32}]
            }
        }
    }
    Model {
        Structure -> selection {Flat, Hierarchical}

        // or 
        // Structure -> string
        // [Structure in {Flat, Hierarchical}]
        [if Context.Model.Structure == Flat then fcard.Predictor.Models.Model = 1 else fcard.Predictor.Models.Model = size Context.Experiment.Regions]
    }
}
