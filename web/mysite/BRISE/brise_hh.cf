General {
    NumberOfWorkers -> integer
    result_storage -> string
    [NumberOfWorkers >= 1]
}

SelectionAlgorithm {
    type -> string
    [type in {Sobol, MersenneTwister}]
}

DomainDescription {
    DataFile -> string
}

TaskConfiguration {
    TaskName -> integer
    xor Scenario {
        FromFile {
            WsFile -> string
            AdditionalParameter * {
                Name -> string
                Value -> string
            }
        }
        FromDescription {
            Problem -> string
            InitializationParameters -> string
            Budget {
                Type -> string
                Amount -> integer
            }
            Hyperparameters -> string
        }
    }
    Objectives + {
        Name -> string
        DataType -> string
        Minimization -> boolean
        Priority -> integer
        ModelPriority -> integer
        ExpectedValuesRange -> floatArray
        MaxTimeToRunTask -> integer ?
    }
    [fcard.Repeater.AcceptableErrorBasedRepeater = fcard.TaskConfiguration.Objectives]
}

abstract OutliersDetector 5 {
    MinActiveNumberOfTasks -> integer
    MaxActiveNumberOfTasks -> integer
    [MinActiveNumberOfTasks >= 3]
    [MaxActiveNumberOfTasks >= 3]
    [MinActiveNumberOfTasks <= MaxActiveNumberOfTasks]
}

or OutliersDetection{
    Dixon : OutliersDetector
    Grubbs : OutliersDetector
    Chauvenet : OutliersDetector
    Quartiles : OutliersDetector
    Mad : OutliersDetector
}

abstract AbstrRepeater {
    MinTasksPerConfiguration -> integer
    MaxTasksPerConfiguration -> integer
    [MinTasksPerConfiguration <= MaxTasksPerConfiguration]
}

xor Repeater{
    DefaultRepeater : AbstrRepeater {
        [MinTasksPerConfiguration >= 2]
        [MaxTasksPerConfiguration >= 2]
    }
    AcceptableErrorBasedRepeater: AbstrRepeater 1{
        [MinTasksPerConfiguration >= 1]
        [MaxTasksPerConfiguration >= 1]
        MaxFailedTasksPerConfiguration -> integer
        BaseAcceptableErrors -> integer
        ConfidenceLevels -> float
        DevicesScaleAccuracies -> integer
        DevicesAccuracyClasses -> integer
        ExperimentAwareness {
            isEnabled -> boolean
            MaxAcceptableErrors -> integer
            RatiosMax -> integer
        }
    }
}

abstract Model {
    Type -> predefined
}

abstract TreeParzenEstimator: Model {
    Parameters {
        TopNPercent -> integer
        RandomFraction -> integer
        BandwidthFactor -> integer
        MinBandwirth -> float
        SamplingSize -> integer
    }
    [Type = 'brise.TreeParzenEstimator']
}

abstract MultiArmedBandit: Model {
    Parameters {
        xor cType{
            int
            float
            std
        }
        c -> float
        [if gcard.cType == float then 0 <= c]
        [if gcard.cType == float then c <= 1]
        [if gcard.cType == std then c = std]
    }
    [type = 'brise.MultiArmedBandit']
}

abstract ModelMock

abstract SciKitLearn {
    Type -> string
    Parameters {
        SamplingSize -> integer
        MinimalScore -> float
        CrossValidationSplits -> integer
        TestSize -> float
        DataPreprocessing {
            OrdinalHyperparameter -> string
            NominalHyperparameter -> string
            IntegerHyperparameter -> string
            FloatHyperparameter -> string
        }
        UnderlyingModelParameters {
            n_iter -> integer
            tol -> float
            normalize -> boolean
        }
    }
}

Predictor {
    WindowSize -> float
    Models {
        xor Model 1 {
            TPE : TreeParzenEstimator
            MAB : MultiArmedBandit
            MM : ModelMock
            skLearn : SciKitLearn
        }
    }
}

StopConditionTriggerLogic {
    Expression -> string
    InspectionParameters {
        RepetitionPerion -> integer
        TimeUnit -> string
        [RepetitionPerion > 0]
        [TimeUnit in {seconds, minutes, hours, days}]
    }
}

abstract SC {
    Name -> string
    Type -> predefined
}

StopCondition {
    QuantityBasedSC : SC 1..5{
        Parameters {
            MaxConfigs -> integer
            [MaxConfigs > 0]
        }
        [Type = QuantityBased]
    }

    GuaranteedSC : SC 1 {
        [Type = Guaranted]
    }

    BadConfigurationBasedSC : SC 1..5{
        Parameters {
            MaxBadConfigurations -> integer
            [MaxBadConfigurations > 0]
        }
        [Type = BadConfigurationBased]
    }

    ImprovementBasedSC : SC 1..5{
        Parameters {
            MaxConfigsWithoutImprovement -> integer
            [MaxConfigsWithoutImprovement > 0]
        }
        [Type = ImprovementBased]
    }

    TimeBasedSC : SC 1..5{
        Parameters {
            MaxRunTime -> integer
            TimeUnit -> string
            [MaxRunTime > 0]
            [TimeUnit in {seconds, minutes, hours, days}]
        }
        [Type = TimeBased]
    }
}

abstract NominalHyperparameter {
    Type -> predefined
    [Type = NominalHyperparameter]
}

abstract MDNominalHyperparameter {
    Type -> predefined
    Model -> string
    [Type = NominalHyperparameter]
    [Model in childs.Predictor.Models]
}

abstract OrdinalHyperparameter {
    Type -> predefined
    Categories -> predefined
    Default -> string
    Model -> predefined
    [Type = OrdinalHyperparameter]
    [Default in Categories]
    [Model in childs.Predictor.Models]
}

abstract IntegerOrdinalHyperparameter {
    Type -> predefined
    Categories -> predefined
    Default -> integer
    Model -> predefined
    [Type = IntegerOrdinalHyperparameter]
    [Default in Categories]
    [Model in childs.Predictor.Models]
}

abstract FloatOrdinalHyperparameter {
    Type -> predefined
    Categories -> predefined
    Default -> float
    Model -> predefined
    [Type = FloatOrdinalHyperparameter]
    [Default in Categories]
    [Model in childs.Predictor.Models]
}

abstract FloatHyperparameter {
    Type -> predefined
    Lower -> predefined
    Upper -> predefined
    Default -> float
    Model -> predefined
    [Default >= Lower]
    [Default <= Upper]
    [Type = FloatHyperparameter]
    [Model in childs.Predictor.Models]
}

abstract IntegerHyperparameter {
    Name -> predefined
    Type -> predefined
    Lower -> predefined
    Upper -> predefined
    Default -> integer
    Model -> predefined
    [Default >= Lower]
    [Default <= Upper]
    [Type = IntegerHyperparameter]
    [Model in childs.Predictor.Models]
}

Experiment : NominalHyperparameter {
    LowLevelHeuristic: MDNominalHyperparameter {
        jMetalPySimulatedAnnealing: MDNominalHyperparameter {
            MutationType: NominalHyperparameter{
                PermutationSwapMutation: MDNominalHyperparameter{
                    MutationProbability: FloatHyperparameter{
                        [Lower = 0]
                        [Upper = 1]
                        [Model = Experiment.LowLevelHeuristic.jMetalPySimulatedAnnealing.MutationType.PermutationSwapMutation.Model]
                    }
                }
                ScrambleMutation: MDNominalHyperparameter{
                    MutationProbability: FloatHyperparameter{
                        [Lower = 0]
                        [Upper = 1]
                        [Model = Experiment.LowLevelHeuristic.jMetalPySimulatedAnnealing.MutationType.PermutationSwapMutation.Model]
                    }
                }
            }
        }
        jMetalPyEvolutionStrategy: MDNominalHyperparameter {
            mu: IntegerHyperparameter {
                [Lower = 1]
                [Upper = 1000]
                [Model = Experiment.LowLevelHeuristic.jMetalPyEvolutionStrategy.Model]
            }
            lambda_ : IntegerHyperparameter{
                [Lower = 1]
                [Upper = 1000]
                [Model = Experiment.LowLevelHeuristic.jMetalPyEvolutionStrategy.Model]
            }
            elitist: OrdinalHyperparameter{
                [Categories = {True, False}]
                [Model = Experiment.LowLevelHeuristic.jMetalPyEvolutionStrategy.Model]
            }
            MutationType: NominalHyperparameter{
                PermutationSwapMutation: MDNominalHyperparameter{
                    MutationProbability: FloatHyperparameter{
                        [Lower = 0]
                        [Upper = 1]
                        [Model = Experiment.LowLevelHeuristic.jMetalPyEvolutionStrategy.MutationType.PermutationSwapMutation.Model]
                    }
                }
                ScrambleMutation: MDNominalHyperparameter{
                    MutationProbability: FloatHyperparameter{
                        [Lower = 0]
                        [Upper = 1]
                        [Model = Experiment.LowLevelHeuristic.jMetalPyEvolutionStrategy.MutationType.PermutationSwapMutation.Model]
                    }
                }
            }
        }
        jMetalEvolutionStrategy: MDNominalHyperparameter {
            mu: IntegerHyperparameter {
                [Lower = 1]
                [Upper = 1000]
                [Model = Experiment.LowLevelHeuristic.jMetalEvolutionStrategy.Model]
            }
            lambda_ : IntegerHyperparameter{
                [Lower = 1]
                [Upper = 1000]
                [Model = Experiment.LowLevelHeuristic.jMetalEvolutionStrategy.Model]
            }
            elitist: OrdinalHyperparameter{
                [Categories = {True, False}]
                [Model = Experiment.LowLevelHeuristic.jMetalEvolutionStrategy.Model]
            }
            MutationProbability: FloatHyperparameter{
                [Lower = 0]
                [Upper = 1]
                [Model = Experiment.LowLevelHeuristic.jMetalEvolutionStrategy.Model]
            }
        }
    }
}

Context {
    Model {
        xor Structure {
           Flat
           Hierarchical
        }
        ModelStructure -> predefined
        [if gcard.Context.Model.Structure == Flat then fcard.Predictor.Models.Model = 1 else fcard.Predictor.Models.Model = 8]
        [ModelStructure = gcard.Context.Model.Structure]
    }
}
